# Labyrinth Wanderer

![alt text](img/LabWanderer.png)

## Maze solving algorithms

- Breadth First Search - Левицький Тарас
- Depth First Search - Лукашенко Поліна
- A* Search - Васильченко Владислав
- Dijkstra’s Algorithm - Засимович Богдан
- Gui & code reviews - Леник Нікіта

---

## Features

- **Uploading maze from csv file** - `#` wall `.` path
- **Generate maze** - creates **empty canvas**, where user can draw. **First, orange cell** - start, **Second, blue cell - end**, next cells represent **barriers(walls)**. **To delete the wall** use **RIGHT MOUSE BUTTON**, also works for start and end.
- **Save Solution** - saves the image of solved labyrinth to `results/solution.jpg`
- **Random generation** - generates the maze of the given size using **DFS**
- **Left drop down menu** - to choose which algorithm to use
- **Right drop down menu** - to choose the size of the labyrinth/empty canvas
- **Right down corner** - timer of algorithm execution in seconds

---
![alt text](</img/gui.png>)

---

## Project Structure

```bash
.
├── main.py # Entry point start this file to run the app
├── requirements.txt
├── results # Directory with labyrinth solutions
│   └── solution.jpg
├── src
│   ├── a_star.py # A*
│   ├── a_star_visual.py # A* implemented with visualisation
│   ├── bfs.py # BFS implemented with visualisation(only)
│   ├── colors.py # constants
│   ├── dfs.py # DFS implemented with visualisation
│   ├── dfs_algorithm.py # DFS
│   ├── dijkstra.py # Dijkstra
│   ├── dijkstra_algorithm.py # Dijkstra implemented with visualisation
│   ├── greedy_a_star.py # Greedy A* implemented with visualisation(only)
│   ├── gui.py # GUI file
│   └── maze.py # GridCell class
├── static
│   └── theme.json
│   # Test labyrinth
├── test_100.csv
├── test_150.csv
└── test_400.csv
```

---

## Requirements

```txt
numpy==2.1.3
pygame==2.6.1
pygame_gui==0.6.12
```

---

## To run the program

```bash
pip install -r requirements.txt

python main.py
```

---

## Звіт

### Проєкт

Наш проєкт представляє застосунок для порівняння та візуалізації виконання алгоритмів. Для реалізації ми вирішили використати бібліотеки `Pygame`, `Pygame_gui` та `NumPy`.

### Складові візуального інтерфейсу

Інтерфейс представляє об'єкт класу `MazeApp`, який має атрибути, зокрема:

Кнопки, що відповідають за завантаження лабіринту через файл, створення порожнього полотна для лабіринту, збереження розв’язаного лабіринту, генерацію лабіринту за допомогою `DFS`.
Спадне меню, яке дозволяє вибрати алгоритм розв’язання лабіринту та задати розмір полотна.
Таймер, який використовується для вимірювання часу виконання алгоритму.

Також для відображення самого лабіринту та його полотна використовується об'єкт класу `MazeWindow`, який створюється лише за умови, що користувач натиснув кнопку, яка відповідає за його створення. Клас відповідає за рендеринг полотна лабіринту та забезпечення взаємодії з користувачем.

### Взаємодія з лабіринтом

Взаємодія з лабіринтом відбувається за допомогою класу `GridCell`, який представляє одну клітинку (вершину) в лабіринті. Всі об'єкти класу `GridCell` зберігаються в атрибуті `grid` класу `MazeWindow`.

#### Grid cell

Об'єкт цього класу представляє єдину вершину в лабіринті, яка має такі атрибути:

- Розташування відносно екрану.
- Координати: колонка та рядок.
- Сусідів, яких може бути лише чотири (зверху, знизу, зліва та справа).
- Колір, який відображає її стани.

##### Стани вершини

- Червоний — вершина відвідана.
- Білий — вершина не була відвідана.
- Чорний — вершина є бар’єром.
- Помаранчевий — вершина є входом у лабіринт.
- Синій — вихід з лабіринту.
- Фіолетовий — правильний шлях від входу до виходу.

Також клас має методи, які дають змогу перевірити та змінити стан кожної клітинки.

Важливим методом для реалізації алгоримту `A*` є

``` python
def __lt__(self, other: object) -> bool:
    """
    Custom comperrison method replaces the '<' operator.
    Compares the current cell with the other
    """
    return False
```

**\__lt\__(less_than)** - гарантує, що будь-яке порівняння двох обʼєктів поверне **False**. Це буде використане у подальшій реалізації алгоритму.

### Випадкова генерація лабіринту

Для випадкової генерації лабіринту використовується пошук в глибину.

1. За допомогою numpy.ones() створюємо квадратну матрицю з одиниць, які відображають стінки.

2. Задаємо координати (вгору, вниз, вліво, вправо), які при кожному виклику функції перемішуються випадковим чином.

3. Ітеруємося по заданим координатам і задаємо нові координати, що віддалені на два кроки від попередніх x, y.

4. Якщо нові координати nx, ny не виходять за межі лабіринту і значення в матриці дорівнює 1, то задаємо клітинці значення 0, що формує майбутній прохід у лабіринті.

5. Викликаємо функцію знову, поки умова з пункту 4 не виконається.

---

## **Алгоритм Дейкстри**

## **Принцип дії:**

Алгоритм Дейкстри використовується, щоб знайти найкоротший шлях від однієї вершини графа до іншої, а також побудувати цей шлях. Спочатку встановлюється початкова вершина з відстанню 0, а всі інші отримують нескінченність. Алгоритм зберігає набір неперевірених вершин, у вигляді черги з пріоритетом, вибираючи кожного разу вершину з найменшою відстанню. Потім оновлює відстані до її сусідів, якщо новий шлях коротший за поточний, та фіксується попередник – вершина, з якої досягнуто найкоротший шлях. Процес повторюється доки не буде досягнута кінцева точка або не будуть відвідані всі вершини в які можливо потрапити з початкової. В кінці знаходиться найкоротший шлях. Він відновлюється шляхом проходження з кінцевої вершини до початкової через збережених попередників. Якщо були відвідані усі вершини, що мають зв’язок з першою, однак не було досягнуто кінця, то шляху від початкової вершини до кінцевої не існує.

## **Реалізація:**

### **Програма містить наступні функції:**

* ```matrix_to_adj_dict(maze: np.array) -> dict[tuple, sеt]```

    Ця функція приймає лабіринт у вигляді двовимірного NumPy array та переводить його в словник, де ключ це координати клітинки, а значення множина її сусідів, що не є стінкою.
    Вхідний словник містить 0, 1, 2, 3, де
    * 0 - порожня клітинка в лабіринті
    * 1 - стінка
    * 2 - старт
    * 3 - кінець
    (старт та кінець також порожні клітинки)
    Для цього вона ітерується по всіх елементах двовимірного списку ```maze``` та для кожної порожньої клітинки визначає її сусідів, перевіряючи кожну сусідню клітинку на порожність, якщо вона порожня то ця клітинка додається до множину сусідів. Також враховуються крайні випадки, коли клітинка знаходиться в першому/останньому рядку/стовпцю.

    ```python
    adjacent_dict[(row, col)] = set()
    if row != 0 and maze[row-1, col] != 1:
        adjacent_dict[(row, col)].add((row-1, col))
    if row != n-1 and maze[row+1, col] != 1:
        adjacent_dict[(row, col)].add((row+1, col))
    if col != 0 and maze[row, col-1] != 1:
        adjacent_dict[(row, col)].add((row, col-1))
    if col != n-1 and maze[row, col+1] != 1:
        adjacent_dict[(row, col)].add((row, col+1))
    ```

    ```row``` - номер рядка
    ```col``` - номер колонки
    ```n``` - розмір лабіринта
    ```maze``` - вхідний Numpy array
    ```adj_dict``` - словник суміжності, який функція створює
    Також функція визначає старт в лабіринті (позначений двійкою) та кінець (позначений трійкою)

    ```python
    if maze[row, col] == 2:
        start = (row, col)
    elif maze[row, col] == 3:
        end = (row, col)
    ```

    Функція повертає кортеж, що містить 3 елементи: координати старту, кінця та словник суміжності.

* ```dijkstra(maze: dict[tuple: set], start: tuple, end: tuple) -> dict[tuple, list] | int```

    Ця функція приймає словник суміжності отриманий в результаті
    виконання попередньої функції, старт та кінець. Повертає словник ```graph```, створений в результаті виконання цієї функції (його опис нижче), де за клітинкою попередником функція ```reconstruct_path``` відтворить шлях. Якщо шляху від старту до кінця немає, функція повертає -1. Функція використовує алгоритм Дейкстри, описаний вище.
    Для цього спочатку створюється словник ```graph```, де кожній вершині відповідає список, який містить поточну найкоротшу відстань від старту до вершини (При створенні для всіх вершин, крім старту відстань визначається як нескінченність, для старту 0), булеве значення (False для всіх крім старту, для нього True), яке позначає чи була відвідана поточна вершина, координати попередника (при створенні None для всіх крім старту, для нього його координати) - сусіда, ідучи з якого найкоротше потрапити в поточну. Також створюється черга з пріоритетом, яка буде містити кортежі, де перше його значення це відстань до клітинки, вона і буде пріоритетом в черзі (чим менша, тим більший пріоритет) та координати клітинки.

    ```python
    graph = {node: [float('inf'), False, None] for node in maze}
    graph[start] = [0, True, start]
    nodes_queue = PriorityQueue()
    nodes_queue.put((0, start))
    ```

    Потім в циклі ```While``` при кожній його ітерації з черги дістається вершина з найбільшим пріоритетом і вона визначається як поточна. Якщо вона є кінцевою, то найкоротший шлях до неї знайдено і повертається словник ```graph```. Якщо ні, то ця вершина позначається відвіданою і для кожної сусідньої з нею вершиною відстань перезаписується, якщо відстань через поточну вершину до сусідньої коротша ніж відстань записана в сусідній, у цьому випадку також перевизначається попередник і ця вершина разом з новою відстанню до неї поміщається в чергу. Потім відбувається перевірка на те чи вона не є порожньою, якщо вона порожня то це означає, що всі вершини, в які існує шлях зі старту вже були відвідані і серед них не було кінця, а отже шляху зі старту в кінець не існує, тому функція повертає -1.

* ```reconstruct_path(graph: dict, start: tuple, end: tuple) -> list[tuple]```
    Ця функція приймає словник ```graph```, старт та кінець. Та повертає найкоротший шлях у вигляду списку кортежів, де кожен кортеж це координати клітинки, яка відвідується на кожному кроці проходження цього шляху. Для цього функція починаючи з кінця йде до його попередника і додає його координати в список ```path``` потім з цього попередника йде до його попередника і додає його координати в список і так далі поки не буде досягнуто початку, тоді функція повертає список в зворотнбому порядку (зворотньому, бо шлях відбудовувався з кінця).

    ```python
    path = []
    cur_node = end
    while True:
        path.append(cur_node)
        if cur_node == start:
            break
        cur_node = graph[cur_node][2]
    return list(reversed(path))
    ```

* ```find_shortest_path(maze_matrix: np.array) -> list[tuple] | int```
    Ця функція об'єднує три попередні. Вона приймає лабіринт у вигляді двовимірного NumPy array та повертає найкоротший шлях у лабіринті від початку до кінця у вигляді списку кортежів, якщо він існує, інакше -1.

    ```python
    maze_dict, start, end = matrix_to_adj_dict(maze_matrix)
    graph = dijkstra(maze_dict, start, end)
    if graph != -1:
        return reconstruct_path(graph, start, end)
    return -1
    ```
    