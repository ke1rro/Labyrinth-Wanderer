# Labyrinth Wanderer

![alt text](img/LabWanderer.png)

## Maze solving algorithms

- Breadth First Search - Левицький Тарас
- Depth First Search - Лукашенко Поліна
- A* Search - Васильченко Владислав
- Dijkstra’s Algorithm - Засимович Богдан
- Gui & code reviews - Леник Нікіта

---

## Project Structure

```bash
.
├── results
│   └── solve.jpg # Photos with the correct path to the given maze
├── src
│   ├── colors.py # Constants
│   ├── gui.py # User Interface module
│   ├── maze.py # GridCell class
│   └── solver.py # Algorithm for solving maze
├── static
│   └── button.json # Themes for GUI
└── test.csv # Test file for maze solving
```

## Requirements

```txt
numpy==2.1.3
pygame==2.6.1
pygame_gui==0.6.12
```

```bash
pip install -r requirements.txt
```

## IF YOU WANT TO IMPLEMENT ANY ALGORITHM FOLLOW THIS STEPS

    1. Create branch with algorithm name
    2. Code the algorithm up to data structure base on MAZE class
    3.
        1. Commit
        2. Push
        3, Pull request
    4. Done



# __Алгоритм Дейкстри__
## __Принцип дії:__
Алгоритм Дейкстри використовується, щоб знайти найкоротший шлях від однієї вершини графа до іншої, а також побудувати цей шлях. Спочатку встановлюється початкова вершина з відстанню 0, а всі інші отримують нескінченність. Алгоритм зберігає набір неперевірених вершин, у вигляді черги з пріоритетом, вибираючи кожного разу вершину з найменшою відстанню. Потім оновлює відстані до її сусідів, якщо новий шлях коротший за поточний, та фіксується попередник – вершина, з якої досягнуто найкоротший шлях. Процес повторюється доки не буде досягнута кінцева точка або не будуть відвідані всі вершини в які можливо потрапити з початкової. В кінці знаходиться найкоротший шлях. Він відновлюється шляхом проходження з кінцевої вершини до початкової через збережених попередників. Якщо були відвідані усі вершини, що мають зв’язок з першою, однак не було досягнуто кінця, то шляху від початкової вершини до кінцевої не існує.
## __Реалізація:__
### __Програма містить наступні функції:__
* ```matrix_to_adj_dict(maze: np.array) -> dict[tuple, sеt]```
    Ця функція приймає лабіринт у вигляді двовимірного NumPy array та переводить його в словник, де ключ це координати клітинки, а значення множина її сусідів, що не є стінкою.
    Вхідний словник містить 0, 1, 2, 3, де
    * 0 - порожня клітинка в лабіринті
    * 1 - стінка
    * 2 - старт
    * 3 - кінець
    (старт та кінець також порожні клітинки)
    Для цього вона ітерується по всіх елементах двовимірного списку ```maze``` та для кожної порожньої клітинки визначає її сусідів, перевіряючи кожну сусідню клітинку на порожність, якщо вона порожня то ця клітинка додається до множину сусідів. Також враховуються крайні випадки, коли клітинка знаходиться в першому/останньому рядку/стовпцю.
    ```python
    adjacent_dict[(row, col)] = set()
    if row != 0 and maze[row-1, col] != 1:
        adjacent_dict[(row, col)].add((row-1, col))
    if row != n-1 and maze[row+1, col] != 1:
        adjacent_dict[(row, col)].add((row+1, col))
    if col != 0 and maze[row, col-1] != 1:
        adjacent_dict[(row, col)].add((row, col-1))
    if col != n-1 and maze[row, col+1] != 1:
        adjacent_dict[(row, col)].add((row, col+1))
    ```
    ```row``` - номер рядка
    ```col``` - номер колонки
    ```n``` - розмір лабіринта
    ```maze``` - вхідний Numpy array
    ```adj_dict``` - словник суміжності, який функція створює
    Також функція визначає старт в лабіринті (позначений двійкою) та кінець (позначений трійкою)
    ```python
    if maze[row, col] == 2:
        start = (row, col)
    elif maze[row, col] == 3:
        end = (row, col)
    ```
    Функція повертає кортеж, що містить 3 елементи: координати старту, кінця та словник суміжності.

* ```dijkstra(maze: dict[tuple: set], start: tuple, end: tuple) -> dict[tuple, list] | int```
    Ця функція приймає словник суміжності отриманий в результаті
    виконання попередньої функції, старт та кінець. Повертає словник ```graph```, створений в результаті виконання цієї функції (його опис нижче), де за клітинкою попередником функція ```reconstruct_path``` відтворить шлях. Якщо шляху від старту до кінця немає, функція повертає -1. Функція використовує алгоритм Дейкстри, описаний вище.
    Для цього спочатку створюється словник ```graph```, де кожній вершині відповідає список, який містить поточну найкоротшу відстань від старту до вершини (При створенні для всіх вершин, крім старту відстань визначається як нескінченність, для старту 0), булеве значення (False для всіх крім старту, для нього True), яке позначає чи була відвідана поточна вершина, координати попередника (при створенні None для всіх крім старту, для нього його координати) - сусіда, ідучи з якого найкоротше потрапити в поточну. Також створюється черга з пріоритетом, яка буде містити кортежі, де перше його значення це відстань до клітинки, вона і буде пріоритетом в черзі (чим менша, тим більший пріоритет) та координати клітинки.
    ```python
    graph = {node: [float('inf'), False, None] for node in maze}
    graph[start] = [0, True, start]
    nodes_queue = PriorityQueue()
    nodes_queue.put((0, start))
    ```
    Потім в циклі ```While``` при кожній його ітерації з черги дістається вершина з найбільшим пріоритетом і вона визначається як поточна. Якщо вона є кінцевою, то найкоротший шлях до неї знайдено і повертається словник ```graph```. Якщо ні, то ця вершина позначається відвіданою і для кожної сусідньої з нею вершиною відстань перезаписується, якщо відстань через поточну вершину до сусідньої коротша ніж відстань записана в сусідній, у цьому випадку також перевизначається попередник і ця вершина разом з новою відстанню до неї поміщається в чергу. Потім відбувається перевірка на те чи вона не є порожньою, якщо вона порожня то це означає, що всі вершини, в які існує шлях зі старту вже були відвідані і серед них не було кінця, а отже шляху зі старту в кінець не існує, тому функція повертає -1.

* ```reconstruct_path(graph: dict, start: tuple, end: tuple) -> list[tuple]```
    Ця функція приймає словник ```graph```, старт та кінець. Та повертає найкоротший шлях у вигляду списку кортежів, де кожен кортеж це координати клітинки, яка відвідується на кожному кроці проходження цього шляху. Для цього функція починаючи з кінця йде до його попередника і додає його координати в список ```path``` потім з цього попередника йде до його попередника і додає його координати в список і так далі поки не буде досягнуто початку, тоді функція повертає список в зворотнбому порядку (зворотньому, бо шлях відбудовувався з кінця).
    ```python
    path = []
    cur_node = end
    while True:
        path.append(cur_node)
        if cur_node == start:
            break
        cur_node = graph[cur_node][2]
    return list(reversed(path))
    ```

* ```find_shortest_path(maze_matrix: np.array) -> list[tuple] | int```
    Ця функція об'єднує три попередні. Вона приймає лабіринт у вигляді двовимірного NumPy array та повертає найкоротший шлях у лабіринті від початку до кінця у вигляді списку кортежів, якщо він існує, інакше -1.
    ```python
    maze_dict, start, end = matrix_to_adj_dict(maze_matrix)
    graph = dijkstra(maze_dict, start, end)
    if graph != -1:
        return reconstruct_path(graph, start, end)
    return -1
    ```